---
title: "Lab: CRUD Operations in PostgreSQL"
week: 04
type: lab
tags: [postgresql, dml, crud, insert, update, delete, select]
difficulty: intermediate
duration: "60 mins"
---

# Lab: CRUD Operations in PostgreSQL

## Prerequisites & Setup

**Before starting this lab, you should have:**
- Completed [Lesson 7 Lab](w04_l07_lab_ddl_implementation.md) - The University schema must be created
- Reviewed [w04_l08_concept_dml_querying.md](w04_l08_concept_dml_querying.md) for DML concepts
- Active PostgreSQL database connection

**What you'll accomplish:**
In this lab, you'll populate the University Course Registration database with realistic data and practice all CRUD operations: INSERT, UPDATE, DELETE, and SELECT.

**Goal:** Master data manipulation operations and develop safe practices for production databases.

---

## Environment Setup

If you're continuing from Lesson 7, you already have the schema created. If not, re-run the Lesson 7 lab first.

```python
# Install required packages (if not already installed)
!pip install -q psycopg2-binary ipython-sql sqlalchemy pandas

# Import libraries
import pandas as pd
import warnings
warnings.filterwarnings('ignore')

# Load SQL magic
%load_ext sql

# Configure SQL Magic
%config SqlMagic.autocommit = False  # Use explicit transactions
%config SqlMagic.feedback = True     # Show row counts
%config SqlMagic.displaycon = False  # Hide connection string
```

### Connect to Your Database

Use the same connection from Lesson 7:

```python
# Replace with your actual connection string
%sql postgresql://postgres:[YOUR-PASSWORD]@db.[YOUR-PROJECT].supabase.co:5432/postgres

# Test connection
%sql SELECT current_database(), current_user;
```

### Verify Schema Exists

```python
%%sql
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'public'
ORDER BY table_name;
```

<details>
<summary>Expected Output</summary>

You should see:
- courses
- departments
- enrollments
- professors
- student_phones
- students

If these tables don't exist, go back to Lesson 7 lab and create them first.

</details>

---

## Step 1: Populate Parent Tables with INSERT

Start with tables that have no dependencies (no foreign keys).

### Insert Departments

```python
%%sql
-- Clean slate for re-runs
DELETE FROM enrollments;
DELETE FROM student_phones;
DELETE FROM courses;
DELETE FROM students;
DELETE FROM professors;
DELETE FROM departments;

-- Insert departments
INSERT INTO departments (name, building) VALUES
    ('Computer Science', 'Tech Building'),
    ('Mathematics', 'Science Hall'),
    ('Physics', 'Science Hall'),
    ('English', 'Arts Building');

-- Verify
SELECT * FROM departments ORDER BY dept_id;
```

<details>
<summary>Expected Output</summary>

| dept_id | name | building |
|---------|------|----------|
| 1 | Computer Science | Tech Building |
| 2 | Mathematics | Science Hall |
| 3 | Physics | Science Hall |
| 4 | English | Arts Building |

</details>

**Key Points:**
- Multi-row INSERT is more efficient than four separate inserts
- `dept_id` is auto-generated by SERIAL
- Order of deletion matters (children first, parents last)

### Insert Professors

Now that departments exist, we can reference them:

```python
%%sql
INSERT INTO professors (name, dept_id) VALUES
    ('Dr. Alice Cooper', 1),
    ('Dr. Bob Taylor', 1),
    ('Dr. Carol White', 2),
    ('Dr. David Lee', 3);

-- Verify with JOIN to see department names
SELECT
    p.emp_id,
    p.name,
    d.name AS department,
    d.building
FROM professors p
JOIN departments d ON p.dept_id = d.dept_id
ORDER BY p.emp_id;
```

<details>
<summary>Expected Output</summary>

| emp_id | name | department | building |
|--------|------|------------|----------|
| 1 | Dr. Alice Cooper | Computer Science | Tech Building |
| 2 | Dr. Bob Taylor | Computer Science | Tech Building |
| 3 | Dr. Carol White | Mathematics | Science Hall |
| 4 | Dr. David Lee | Physics | Science Hall |

</details>

**Key Points:**
- Foreign key values (dept_id) must exist in the parent table (departments)
- JOIN allows us to verify the relationships immediately

---

## Step 2: Insert with Self-Referencing Foreign Keys

Courses can have prerequisites (which are also courses). We need to insert base courses first, then courses with prerequisites.

### Create Course Hierarchy

```python
%%sql
-- Base courses (no prerequisites)
INSERT INTO courses (course_code, title, credits, prereq_code) VALUES
    ('COMP1101', 'Intro to Programming', 3, NULL),
    ('COMP1201', 'Data Structures', 4, NULL),
    ('MATH1101', 'Calculus I', 4, NULL);

-- Now insert courses that depend on the base courses
INSERT INTO courses (course_code, title, credits, prereq_code) VALUES
    ('COMP2201', 'Algorithms', 4, 'COMP1201'),
    ('COMP3301', 'Database Systems', 4, 'COMP2201'),
    ('MATH2101', 'Calculus II', 4, 'MATH1101');

-- Verify the prerequisite chain
SELECT
    c1.course_code,
    c1.title,
    c1.credits,
    c2.course_code AS prereq_code,
    c2.title AS prereq_title
FROM courses c1
LEFT JOIN courses c2 ON c1.prereq_code = c2.course_code
ORDER BY c1.course_code;
```

<details>
<summary>Expected Output</summary>

| course_code | title | credits | prereq_code | prereq_title |
|-------------|-------|---------|-------------|--------------|
| COMP1101 | Intro to Programming | 3 | NULL | NULL |
| COMP1201 | Data Structures | 4 | NULL | NULL |
| COMP2201 | Algorithms | 4 | COMP1201 | Data Structures |
| COMP3301 | Database Systems | 4 | COMP2201 | Algorithms |
| MATH1101 | Calculus I | 4 | NULL | NULL |
| MATH2101 | Calculus II | 4 | MATH1101 | Calculus I |

</details>

**Key Points:**
- LEFT JOIN shows all courses, even those without prerequisites
- Self-referencing foreign keys create hierarchies (prerequisite chains)
- Insert order matters: parents before children

### Visualize the Prerequisite Chain

```python
%%sql
-- Follow the chain: COMP3301 → COMP2201 → COMP1201
SELECT
    level,
    course_code,
    title
FROM (
    SELECT 1 AS level, course_code, title FROM courses WHERE course_code = 'COMP1201'
    UNION ALL
    SELECT 2 AS level, course_code, title FROM courses WHERE course_code = 'COMP2201'
    UNION ALL
    SELECT 3 AS level, course_code, title FROM courses WHERE course_code = 'COMP3301'
) AS chain
ORDER BY level;
```

<details>
<summary>Expected Output</summary>

| level | course_code | title |
|-------|-------------|-------|
| 1 | COMP1101 | Data Structures |
| 2 | COMP2201 | Algorithms |
| 3 | COMP3301 | Database Systems |

Shows the prerequisite progression for Database Systems course.

</details>

---

## Step 3: Multi-Row Inserts with Composite Keys

### Insert Students

```python
%%sql
INSERT INTO students (name, email, dob) VALUES
    ('Alice Johnson', 'alice.j@university.edu', '2000-05-15'),
    ('Bob Smith', 'bob.s@university.edu', '1999-08-22'),
    ('Carol Davis', 'carol.d@university.edu', '2001-03-10'),
    ('David Wilson', 'david.w@university.edu', '2000-11-30'),
    ('Eve Martinez', 'eve.m@university.edu', '2002-01-05');

SELECT student_id, name, email, dob
FROM students
ORDER BY student_id;
```

<details>
<summary>Expected Output</summary>

| student_id | name | email | dob |
|------------|------|-------|-----|
| 1 | Alice Johnson | alice.j@university.edu | 2000-05-15 |
| 2 | Bob Smith | bob.s@university.edu | 1999-08-22 |
| 3 | Carol Davis | carol.d@university.edu | 2001-03-10 |
| 4 | David Wilson | david.w@university.edu | 2000-11-30 |
| 5 | Eve Martinez | eve.m@university.edu | 2002-01-05 |

</details>

### Insert Multi-valued Attributes (Student Phones)

Students can have multiple phone numbers - this is a **composite primary key** situation.

```python
%%sql
INSERT INTO student_phones (student_id, phone_number, phone_type) VALUES
    (1, '555-0101', 'mobile'),
    (1, '555-0102', 'home'),
    (2, '555-0201', 'mobile'),
    (3, '555-0301', 'mobile'),
    (3, '555-0302', 'emergency'),
    (5, '555-0501', 'mobile');

-- Verify with JOIN to see student names
SELECT
    s.student_id,
    s.name,
    sp.phone_number,
    sp.phone_type
FROM students s
LEFT JOIN student_phones sp ON s.student_id = sp.student_id
ORDER BY s.student_id, sp.phone_type;
```

<details>
<summary>Expected Output</summary>

| student_id | name | phone_number | phone_type |
|------------|------|--------------|------------|
| 1 | Alice Johnson | 555-0102 | home |
| 1 | Alice Johnson | 555-0101 | mobile |
| 2 | Bob Smith | 555-0201 | mobile |
| 3 | Carol Davis | 555-0302 | emergency |
| 3 | Carol Davis | 555-0301 | mobile |
| 4 | David Wilson | NULL | NULL |
| 5 | Eve Martinez | 555-0501 | mobile |

Note: David has no phone numbers (LEFT JOIN shows NULL).

</details>

**Key Points:**
- Composite primary key: `(student_id, phone_number)` together must be unique
- Same student can have multiple numbers, but not duplicate numbers
- LEFT JOIN reveals students without phone numbers

---

## Step 4: INSERT with DEFAULT Values

The `enrollments` table has `enrollment_date` with `DEFAULT CURRENT_DATE`.

### Test DEFAULT Behavior

```python
%%sql
-- enrollment_date will automatically use CURRENT_DATE
INSERT INTO enrollments (student_id, course_code) VALUES
    (1, 'COMP1101'),
    (1, 'MATH1101'),
    (2, 'COMP1101'),
    (2, 'COMP1201'),
    (3, 'COMP1101'),
    (3, 'COMP1201'),
    (3, 'MATH1101');

SELECT * FROM enrollments ORDER BY student_id, course_code;
```

<details>
<summary>Expected Output</summary>

| student_id | course_code | enrollment_date | grade |
|------------|-------------|-----------------|-------|
| 1 | COMP1101 | 2026-02-08 | NULL |
| 1 | MATH1101 | 2026-02-08 | NULL |
| 2 | COMP1101 | 2026-02-08 | NULL |
| 2 | COMP1201 | 2026-02-08 | NULL |
| 3 | COMP1101 | 2026-02-08 | NULL |
| 3 | COMP1201 | 2026-02-08 | NULL |
| 3 | MATH1101 | 2026-02-08 | NULL |

(Date will be today's date)

</details>

### Override DEFAULT with Explicit Value

```python
%%sql
-- Insert with explicit enrollment date (backdating)
INSERT INTO enrollments (student_id, course_code, enrollment_date) VALUES
    (4, 'COMP1101', '2024-01-15'),
    (5, 'MATH1101', '2024-01-15');

-- Verify both default and explicit dates
SELECT student_id, course_code, enrollment_date
FROM enrollments
WHERE student_id IN (4, 5)
ORDER BY student_id;
```

<details>
<summary>Expected Output</summary>

| student_id | course_code | enrollment_date |
|------------|-------------|-----------------|
| 4 | COMP1101 | 2024-01-15 |
| 5 | MATH1101 | 2024-01-15 |

</details>

---

## Step 5: UPDATE Operations

Now that we have data, let's modify it.

### Simple UPDATE: Set Grades

```python
%%sql
-- Award grade to a single student
UPDATE enrollments
SET grade = 'A'
WHERE student_id = 1 AND course_code = 'COMP1101';

-- Verify
SELECT * FROM enrollments WHERE student_id = 1 AND course_code = 'COMP1101';
```

<details>
<summary>Expected Output</summary>

| student_id | course_code | enrollment_date | grade |
|------------|-------------|-----------------|-------|
| 1 | COMP1101 | 2026-02-08 | A |

</details>

### Multi-Row UPDATE

```python
%%sql
-- Award grades to multiple students in the same course
UPDATE enrollments
SET grade = 'B'
WHERE course_code = 'MATH1101' AND student_id IN (1, 3);

-- Verify
SELECT student_id, course_code, grade
FROM enrollments
WHERE course_code = 'MATH1101'
ORDER BY student_id;
```

<details>
<summary>Expected Output</summary>

| student_id | course_code | grade |
|------------|-------------|-------|
| 1 | MATH1101 | B |
| 3 | MATH1101 | B |
| 5 | MATH1101 | NULL |

</details>

### Conditional UPDATE with CASE

```python
%%sql
-- Award grades based on student_id (simulating different performance)
UPDATE enrollments
SET grade = CASE
    WHEN student_id = 2 AND course_code = 'COMP1101' THEN 'A'
    WHEN student_id = 2 AND course_code = 'COMP1201' THEN 'B'
    WHEN student_id = 3 AND course_code = 'COMP1101' THEN 'A'
    WHEN student_id = 3 AND course_code = 'COMP1201' THEN 'A'
    ELSE grade
END
WHERE student_id IN (2, 3);

-- Verify
SELECT student_id, course_code, grade
FROM enrollments
WHERE student_id IN (2, 3)
ORDER BY student_id, course_code;
```

<details>
<summary>Expected Output</summary>

| student_id | course_code | grade |
|------------|-------------|-------|
| 2 | COMP1101 | A |
| 2 | COMP1201 | B |
| 3 | COMP1101 | A |
| 3 | COMP1201 | A |
| 3 | MATH1101 | B |

Note: MATH1101 grade unchanged (ELSE grade keeps existing value).

</details>

### Safe UPDATE Pattern: SELECT Before UPDATE

**Best Practice:** Always preview the changes before executing.

```python
%%sql
-- Step 1: SELECT to preview which rows will be affected
SELECT * FROM students WHERE student_id = 1;
```

```python
%%sql
-- Step 2: If results look correct, UPDATE
UPDATE students
SET email = 'alice.johnson.new@university.edu'
WHERE student_id = 1;
```

```python
%%sql
-- Step 3: Verify the change
SELECT * FROM students WHERE student_id = 1;
```

<details>
<summary>Expected Output</summary>

| student_id | name | email | dob |
|------------|------|-------|-----|
| 1 | Alice Johnson | alice.johnson.new@university.edu | 2000-05-15 |

</details>

---

## Step 6: DELETE Operations with Safety Checks

### Safe DELETE Pattern

```python
%%sql
-- Step 1: Preview what will be deleted (use SELECT)
SELECT * FROM enrollments WHERE student_id = 4;
```

<details>
<summary>Expected Output</summary>

| student_id | course_code | enrollment_date | grade |
|------------|-------------|-----------------|-------|
| 4 | COMP1101 | 2024-01-15 | NULL |

</details>

```python
%%sql
-- Step 2: Verify count
SELECT COUNT(*) AS rows_to_delete FROM enrollments WHERE student_id = 4;
```

```python
%%sql
-- Step 3: If correct, DELETE
DELETE FROM enrollments WHERE student_id = 4;

-- Step 4: Verify deletion
SELECT COUNT(*) FROM enrollments WHERE student_id = 4;  -- Should return 0
```

### Test Foreign Key CASCADE Behavior

Remember: `student_phones` has `ON DELETE CASCADE`.

```python
%%sql
-- Check phones for student 1
SELECT * FROM student_phones WHERE student_id = 1;
```

<details>
<summary>Expected Output</summary>

| student_id | phone_number | phone_type |
|------------|--------------|------------|
| 1 | 555-0101 | mobile |
| 1 | 555-0102 | home |

</details>

```python
%%sql
-- Delete student 1 (should CASCADE to student_phones)
-- First, let's use a transaction for safety
BEGIN;

DELETE FROM students WHERE student_id = 1;

-- Verify CASCADE deletion
SELECT * FROM student_phones WHERE student_id = 1;  -- Should be empty

-- Roll back if you want to keep the data
ROLLBACK;

-- Or commit to make it permanent
-- COMMIT;
```

### Test Foreign Key RESTRICT Behavior

Remember: `enrollments.course_code` has `ON DELETE RESTRICT`.

```python
%%sql
-- Try to delete a course that has enrollments
DELETE FROM courses WHERE course_code = 'COMP1101';
```

You should see an error:
```
ERROR: update or delete on table "courses" violates foreign key constraint
DETAIL: Key (course_code)=(COMP1101) is still referenced from table "enrollments"
```

**Fix:** Delete enrollments first, then the course:

```python
%%sql
BEGIN;

-- Delete enrollments first
DELETE FROM enrollments WHERE course_code = 'COMP1101';

-- Now delete the course
DELETE FROM courses WHERE course_code = 'COMP1101';

-- Roll back to keep our data
ROLLBACK;
```

---

## Step 7: Complex SELECT Queries

### Basic Filtering and Sorting

```python
%%sql
-- Students enrolled in COMP courses
SELECT DISTINCT s.student_id, s.name, s.email
FROM students s
JOIN enrollments e ON s.student_id = e.student_id
WHERE e.course_code LIKE 'COMP%'
ORDER BY s.name;
```

<details>
<summary>Expected Output</summary>

| student_id | name | email |
|------------|------|-------|
| 1 | Alice Johnson | alice.johnson.new@university.edu |
| 2 | Bob Smith | bob.s@university.edu |
| 3 | Carol Davis | carol.d@university.edu |

</details>

### Aggregation with GROUP BY

```python
%%sql
-- Count enrollments per course
SELECT
    c.course_code,
    c.title,
    COUNT(e.student_id) AS enrollment_count
FROM courses c
LEFT JOIN enrollments e ON c.course_code = e.course_code
GROUP BY c.course_code, c.title
ORDER BY enrollment_count DESC, c.course_code;
```

<details>
<summary>Expected Output</summary>

| course_code | title | enrollment_count |
|-------------|-------|------------------|
| COMP1101 | Intro to Programming | 3 |
| COMP1201 | Data Structures | 2 |
| MATH1101 | Calculus I | 2 |
| COMP2201 | Algorithms | 0 |
| COMP3301 | Database Systems | 0 |
| MATH2101 | Calculus II | 0 |

</details>

### Find Students Not Enrolled in Any Course

```python
%%sql
SELECT s.student_id, s.name, s.email
FROM students s
LEFT JOIN enrollments e ON s.student_id = e.student_id
WHERE e.student_id IS NULL;
```

<details>
<summary>Expected Output</summary>

| student_id | name | email |
|------------|------|-------|
| 4 | David Wilson | david.w@university.edu |

(Assuming we deleted David's enrollment earlier)

</details>

### Students Enrolled in Multiple Specific Courses

```python
%%sql
-- Find students enrolled in BOTH COMP1101 AND MATH1101
SELECT s.student_id, s.name
FROM students s
WHERE EXISTS (
    SELECT 1 FROM enrollments e1
    WHERE e1.student_id = s.student_id AND e1.course_code = 'COMP1101'
)
AND EXISTS (
    SELECT 1 FROM enrollments e2
    WHERE e2.student_id = s.student_id AND e2.course_code = 'MATH1101'
);
```

<details>
<summary>Expected Output</summary>

| student_id | name |
|------------|------|
| 1 | Alice Johnson |
| 3 | Carol Davis |

</details>

### Grade Distribution per Course

```python
%%sql
SELECT
    course_code,
    grade,
    COUNT(*) AS student_count
FROM enrollments
WHERE grade IS NOT NULL
GROUP BY course_code, grade
ORDER BY course_code, grade;
```

<details>
<summary>Expected Output</summary>

| course_code | grade | student_count |
|-------------|-------|---------------|
| COMP1101 | A | 3 |
| COMP1201 | A | 1 |
| COMP1201 | B | 1 |
| MATH1101 | B | 2 |

</details>

---

## Your Turn! (Exercises)

### Exercise 1: Bulk Data Loading

**Task:** Insert 10 more students using Python to generate data. Use realistic names and emails.

```python
import random
from datetime import date, timedelta

# Generate student data
students_data = []
first_names = ['Emma', 'Liam', 'Olivia', 'Noah', 'Ava', 'Ethan', 'Sophia', 'Mason', 'Isabella', 'William']
last_names = ['Brown', 'Johnson', 'Williams', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez', 'Hernandez']

for i in range(10):
    first = random.choice(first_names)
    last = random.choice(last_names)
    name = f"{first} {last}"
    email = f"{first.lower()}.{last.lower()}{i}@university.edu"
    # Random DOB between 1998 and 2003
    dob = date(2000, 1, 1) + timedelta(days=random.randint(0, 1825))
    students_data.append((name, email, str(dob)))

# TODO: Write INSERT statement to add these students
# Hint: Build a multi-row INSERT using the students_data list
```

<details>
<summary>Solution</summary>

~~~python
# Build INSERT statement
values = ", ".join([f"('{name}', '{email}', '{dob}')" for name, email, dob in students_data])
insert_query = f"INSERT INTO students (name, email, dob) VALUES {values}"

%sql $insert_query

# Verify
%sql SELECT COUNT(*) FROM students;
~~~

</details>

### Exercise 2: Conditional Updates

**Task:** Update all enrollments for COMP1101:
- If enrolled before '2025-01-01', set grade to 'A'
- Otherwise, set grade to 'B'

```python
%%sql
-- TODO: Write UPDATE with CASE statement
```

<details>
<summary>Solution</summary>

~~~python
%%sql
UPDATE enrollments
SET grade = CASE
    WHEN enrollment_date < '2025-01-01' THEN 'A'
    ELSE 'B'
END
WHERE course_code = 'COMP1101';

-- Verify
SELECT course_code, enrollment_date, grade
FROM enrollments
WHERE course_code = 'COMP1101';
~~~

</details>

### Exercise 3: Safe Delete with Transactions

**Task:** Delete all enrollments with NULL grades, but use a transaction so you can rollback if needed.

```python
%%sql
-- TODO: Use BEGIN, DELETE, verify, then COMMIT or ROLLBACK
```

<details>
<summary>Solution</summary>

~~~python
%%sql
BEGIN;

-- Preview what will be deleted
SELECT * FROM enrollments WHERE grade IS NULL;

-- Delete
DELETE FROM enrollments WHERE grade IS NULL;

-- Verify count
SELECT COUNT(*) FROM enrollments WHERE grade IS NULL;  -- Should be 0

-- Decide: COMMIT or ROLLBACK
-- COMMIT;  -- To make permanent
ROLLBACK;  -- To undo
~~~

</details>

### Exercise 4: Complex Query - Course Prerequisites Report

**Task:** Write a query that shows each course with its prerequisite, and count how many students are enrolled in each.

```python
%%sql
-- TODO: JOIN courses with itself, and with enrollments
-- Show: course_code, title, prereq_title, enrollment_count
```

<details>
<summary>Solution</summary>

~~~python
%%sql
SELECT
    c1.course_code,
    c1.title,
    c2.title AS prereq_title,
    COUNT(e.student_id) AS enrollment_count
FROM courses c1
LEFT JOIN courses c2 ON c1.prereq_code = c2.course_code
LEFT JOIN enrollments e ON c1.course_code = e.course_code
GROUP BY c1.course_code, c1.title, c2.title
ORDER BY c1.course_code;
~~~

</details>

### Exercise 5: Data Export to CSV

**Task:** Export enrollment data to a CSV file using DuckDB for further analysis in Pandas.

```python
import duckdb

# TODO: Connect DuckDB to your PostgreSQL data and export
# Hint: Use duckdb.read_csv() or directly query PostgreSQL connection string
```

<details>
<summary>Solution</summary>

~~~python
# Method 1: Export from PostgreSQL to Pandas to CSV
df = %sql SELECT * FROM enrollments
df_pandas = df.DataFrame()
df_pandas.to_csv('enrollments.csv', index=False)

# Method 2: Use DuckDB to query PostgreSQL directly (advanced)
import duckdb
conn = duckdb.connect(':memory:')
# Note: DuckDB can't directly connect to PostgreSQL without additional setup
# So we use the Pandas method for this lab
~~~

</details>

---

## Summary

Congratulations! In this lab, you have successfully:

1. ✅ Populated a complete database with INSERT statements
2. ✅ Used multi-row inserts for efficiency
3. ✅ Worked with DEFAULT values and auto-generated IDs
4. ✅ Modified data with UPDATE statements (simple and conditional)
5. ✅ Safely removed data with DELETE using the SELECT-first pattern
6. ✅ Tested foreign key CASCADE and RESTRICT behaviors
7. ✅ Queried data with complex WHERE, ORDER BY, and JOIN clauses
8. ✅ Used transactions for data safety (BEGIN, COMMIT, ROLLBACK)
9. ✅ Practiced aggregations with GROUP BY and COUNT

**Key Takeaways:**

- **CRUD operations are the foundation** of all database applications
- **Always use WHERE with UPDATE/DELETE** - Forgetting WHERE affects all rows!
- **SELECT before UPDATE/DELETE** - Preview changes before executing
- **Transactions provide safety** - Use BEGIN/ROLLBACK for risky operations
- **Foreign keys enforce referential integrity** - Understand CASCADE vs RESTRICT
- **Multi-row operations are faster** - Use batch inserts when possible

**What's Next:**

You now have a fully functional database with:
- 4 departments
- 4 professors
- 6 courses (with prerequisite relationships)
- 5+ students
- Phone numbers and enrollments with grades

**Week 05 Preview:** Next week, you'll learn **analytical SQL** - JOINs, aggregations, window functions, and the transition from OLTP (PostgreSQL) to OLAP (DuckDB) for high-performance data analysis.

---

## Troubleshooting

### UPDATE/DELETE Affects Wrong Rows

**Problem:** Updated/deleted more rows than expected
- **Solution:** Use BEGIN before dangerous operations, verify with SELECT, then COMMIT or ROLLBACK
- **Prevention:** Always test WHERE clause with SELECT first

### Foreign Key Violations

**Problem:** Can't delete row because it's referenced elsewhere
- **Solution:** Delete child records first, or use CASCADE (carefully)
- **Prevention:** Understand your foreign key relationships (ON DELETE RESTRICT vs CASCADE)

### Transaction Not Committed

**Problem:** Changes don't persist after closing connection
- **Solution:** Explicitly COMMIT after successful operations
- **Check:** `%config SqlMagic.autocommit` setting

### Duplicate Key Errors

**Problem:** "violates unique constraint" or "duplicate key value"
- **Solution:** Check UNIQUE and PRIMARY KEY constraints
- **Prevention:** Use INSERT ... ON CONFLICT (advanced PostgreSQL feature)
